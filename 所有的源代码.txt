# ======= 源文件: src\__init__.py =======


# ======= 源文件: src\config\__init__.py =======


# ======= 源文件: src\config\config.yaml =======
# 项目基本信息
project_name: "my_project"
experiment_name: "default"

# 首次启动时间（自动生成）
first_start_time: null

# 基础目录
base_dir: "d:/logs"

# 日志配置
logger:
  # 全局日志级别
  global_console_level: "info"
  global_file_level: "debug"

  # 当前会话目录（自动生成）
  current_session_dir: null

  # 模块特定配置（可选）
  module_levels: {}
  #   module_name:
  #     console_level: "debug"
  #     file_level: "detail"

# 其他配置项...
# training:
#   batch_size: 32
#   learning_rate: 0.001
# ...

# ======= 源文件: src\custom_logger\__init__.py =======
# src/custom_logger/__init__.py

from .manager import (
    init_custom_logger_system,
    get_logger,
    tear_down_custom_logger_system,
    is_initialized,
)

from .logger import CustomLogger

from .types import (
    DEBUG, INFO, WARNING, ERROR, CRITICAL, EXCEPTION,
    DETAIL, W_SUMMARY, W_DETAIL,
    parse_level_name, get_level_name,
)

__all__ = [
    # 主要接口
    'init_custom_logger_system',
    'get_logger',
    'tear_down_custom_logger_system',
    'is_initialized',

    # 类
    'CustomLogger',

    # 常量和工具
    'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL', 'EXCEPTION',
    'DETAIL', 'W_SUMMARY', 'W_DETAIL',
    'parse_level_name', 'get_level_name',
]

# ======= 源文件: src\custom_logger\config.py =======
# src/custom_logger/config.py
from __future__ import annotations
from datetime import datetime

start_time = datetime.now()

import os
from typing import Dict, Any, Optional
from config_manager import get_config_manager
from is_debug import is_debug
from .types import parse_level_name

# 默认配置
DEFAULT_CONFIG = {
    "project_name": "my_project",
    "experiment_name": "default",
    "first_start_time": None,
    "base_dir": "d:/logs",
    'logger': {
        "global_console_level": "info",
        "global_file_level": "debug",
        "current_session_dir": None,
        "module_levels": {},
    },
}

# 全局配置路径缓存
_cached_config_path: Optional[str] = None


def get_cached_config_path() -> Optional[str]:
    """获取缓存的配置路径（用于测试）"""
    return _cached_config_path


def set_config_path(config_path: Optional[str]) -> None:
    """设置配置文件路径"""
    global _cached_config_path
    _cached_config_path = config_path

    # 同时设置环境变量供子进程使用
    if config_path is not None and config_path != "":
        os.environ['CUSTOM_LOGGER_CONFIG_PATH'] = config_path
    else:
        # 当设置为None或空字符串时，完全清理环境变量
        if 'CUSTOM_LOGGER_CONFIG_PATH' in os.environ:
            del os.environ['CUSTOM_LOGGER_CONFIG_PATH']
    return


def get_config_file_path() -> str:
    """获取配置文件路径"""
    # 优先级：缓存路径 > 环境变量 > 默认路径
    if _cached_config_path is not None and _cached_config_path != "":
        return _cached_config_path

    env_path = os.environ.get('CUSTOM_LOGGER_CONFIG_PATH')
    if env_path and env_path.strip() != "":
        return env_path

    default_path = os.path.join("config", "config.yaml")
    return default_path


def init_config(config_path: Optional[str] = None) -> None:
    """初始化配置"""
    # 设置配置路径
    if config_path is not None:
        set_config_path(config_path)

    actual_config_path = get_config_file_path()
    cfg = get_config_manager(config_path=actual_config_path)

    # 检查配置是否已存在，使用新的结构
    if not hasattr(cfg, 'logger'):
        # 创建默认配置结构
        for key, value in DEFAULT_CONFIG.items():
            if key == 'logger':
                # 为logger创建对象而不是字典
                logger_obj = type('LoggerConfig', (), {})()
                for sub_key, sub_value in value.items():
                    setattr(logger_obj, sub_key, sub_value)
                setattr(cfg, key, logger_obj)
            else:
                setattr(cfg, key, value)

    # 设置第一次启动时间
    if cfg.first_start_time is None:
        cfg.first_start_time = start_time.isoformat()

    # 创建当前会话目录
    session_dir = _create_session_dir(cfg)
    cfg.logger.current_session_dir = session_dir

    return


def _create_session_dir(cfg) -> str:
    """创建当前会话的日志目录"""
    # 获取配置值
    base_dir = getattr(cfg, 'base_dir', 'd:/logs')
    project_name = getattr(cfg, 'project_name', 'my_project')
    experiment_name = getattr(cfg, 'experiment_name', 'default')
    first_start_time_str = getattr(cfg, 'first_start_time', None)

    # debug模式添加debug层
    if is_debug():
        base_dir = os.path.join(str(base_dir), "debug")

    # 解析第一次启动时间
    first_start = datetime.fromisoformat(first_start_time_str)
    date_str = first_start.strftime("%Y%m%d")
    time_str = first_start.strftime("%H%M%S")

    # 构建完整路径
    session_dir = os.path.join(str(base_dir), str(project_name), str(experiment_name), "logs", date_str, time_str)

    # 创建目录
    os.makedirs(session_dir, exist_ok=True)

    return session_dir


def get_config() -> Any:
    """获取配置"""
    config_path = get_config_file_path()
    cfg = get_config_manager(config_path=config_path)
    if not hasattr(cfg, 'logger'):
        raise RuntimeError("日志系统未初始化，请先调用 init_custom_logger_system()")

    return cfg.logger


def get_root_config() -> Any:
    """获取根配置对象（用于formatter访问first_start_time）"""
    config_path = get_config_file_path()
    cfg = get_config_manager(config_path=config_path)
    if not hasattr(cfg, 'logger'):
        raise RuntimeError("日志系统未初始化，请先调用 init_custom_logger_system()")
    return cfg


def get_console_level(module_name: str) -> int:
    """获取模块的控制台日志级别"""
    cfg = get_config()

    # 获取模块级别配置
    module_levels = getattr(cfg, 'module_levels', {})
    global_level = getattr(cfg, 'global_console_level', 'info')

    module_config = module_levels.get(module_name, {}) if hasattr(module_levels, 'get') else module_levels.get(
        module_name, {})

    # 优先使用模块特定配置
    if 'console_level' in module_config:
        level_name = module_config['console_level']
    else:
        level_name = global_level

    level_value = parse_level_name(level_name)
    return level_value


def get_file_level(module_name: str) -> int:
    """获取模块的文件日志级别"""
    cfg = get_config()

    # 获取模块级别配置
    module_levels = getattr(cfg, 'module_levels', {})
    global_level = getattr(cfg, 'global_file_level', 'debug')

    module_config = module_levels.get(module_name, {}) if hasattr(module_levels, 'get') else module_levels.get(
        module_name, {})

    # 优先使用模块特定配置
    if 'file_level' in module_config:
        level_name = module_config['file_level']
    else:
        level_name = global_level

    level_value = parse_level_name(level_name)
    return level_value

# ======= 源文件: src\custom_logger\formatter.py =======
# src/custom_logger/formatter.py
from __future__ import annotations
from datetime import datetime

start_time = datetime.now()

import os
import sys
import traceback
import inspect
from typing import Tuple, Optional
from .config import get_config


def get_caller_info() -> Tuple[str, int]:
    """获取调用者信息（文件名和行号）"""
    frame = None
    try:
        # 获取调用栈
        stack = inspect.stack()

        # 找到第一个不在custom_logger包内的调用者
        for frame_info in stack:
            filename = frame_info.filename
            if 'custom_logger' not in filename:
                # 提取文件名（不含路径和扩展名）
                basename = os.path.basename(filename)
                name_without_ext = os.path.splitext(basename)[0]

                # 限制为8个字符
                if len(name_without_ext) > 8:
                    module_name = name_without_ext[:8]
                else:
                    module_name = name_without_ext

                line_number = frame_info.lineno
                return module_name, line_number

        # 如果没找到，使用默认值
        return "unknown", 0

    except Exception:
        return "error", 0


def format_elapsed_time(start_time_iso: str, current_time: datetime) -> str:
    """格式化运行时长"""
    try:
        start_time_dt = datetime.fromisoformat(start_time_iso)
        elapsed = current_time - start_time_dt
        total_seconds = elapsed.total_seconds()

        hours, remainder = divmod(int(total_seconds), 3_600)
        minutes, seconds_int = divmod(remainder, 60)

        # 计算带小数的秒数
        fractional_seconds = total_seconds - (hours * 3_600 + minutes * 60)

        elapsed_str = f"{hours}:{minutes:02d}:{fractional_seconds:05.2f}"
        return elapsed_str

    except Exception:
        return "0:00:00.00"


def format_pid(pid: int) -> str:
    """格式化进程ID"""
    pid_str = f"{pid:>6}"
    return pid_str


def format_log_message(
        level_name: str,
        message: str,
        module_name: str,
        args: tuple,
        kwargs: dict
) -> str:
    """格式化日志消息内容"""
    try:
        if args or kwargs:
            formatted_message = message.format(*args, **kwargs)
        else:
            formatted_message = message
        return formatted_message
    except Exception as e:
        # 格式化失败时返回原始消息和错误信息
        error_msg = f"{message} [格式化错误: {e}]"
        if args:
            error_msg += f" args={args}"
        if kwargs:
            error_msg += f" kwargs={kwargs}"
        return error_msg


def create_log_line(
        level_name: str,
        message: str,
        module_name: str,
        args: tuple,
        kwargs: dict
) -> str:
    """创建完整的日志行"""
    from .config import get_root_config

    cfg = get_root_config()
    current_time = datetime.now()

    # 获取各个组件
    pid_str = format_pid(os.getpid())
    caller_module, line_number = get_caller_info()
    timestamp = current_time.strftime('%Y-%m-%d %H:%M:%S')

    # 获取第一次启动时间
    first_start_time = getattr(cfg, 'first_start_time', None)
    elapsed_str = format_elapsed_time(first_start_time, current_time)
    formatted_message = format_log_message(level_name, message, module_name, args, kwargs)

    # 组装日志行，新格式：[PID | 模块名 : 行号]，模块名8位左对齐，行号4位对齐，级别左对齐9字符
    log_line = f"[{pid_str} | {caller_module:<8} : {line_number:>4}] {timestamp} - {elapsed_str} - {level_name:<9} - {formatted_message}"

    return log_line


def get_exception_info() -> Optional[str]:
    """获取异常信息"""
    try:
        exc_type, exc_value, exc_traceback = sys.exc_info()
        if exc_type is not None:
            tb_lines = traceback.format_exception(exc_type, exc_value, exc_traceback)
            tb_str = ''.join(tb_lines)
            return tb_str
        return None
    except Exception:
        return None

# ======= 源文件: src\custom_logger\logger.py =======
# src/custom_logger/logger.py
from __future__ import annotations
from datetime import datetime

start_time = datetime.now()

import sys
import os
from typing import Optional, Any
from .types import (
    DEBUG, INFO, WARNING, ERROR, CRITICAL, EXCEPTION,
    DETAIL, W_SUMMARY, W_DETAIL, get_level_name
)
from .config import get_console_level, get_file_level
from .formatter import create_log_line, get_exception_info
from .writer import write_log_async


# Windows CMD颜色支持
def _enable_windows_ansi_support() -> bool:
    """启用Windows ANSI颜色支持"""
    if os.name != 'nt':
        return True  # 非Windows系统直接返回True

    try:
        import ctypes
        from ctypes import wintypes

        # 获取stdout句柄
        kernel32 = ctypes.windll.kernel32
        handle = kernel32.GetStdHandle(-11)  # STD_OUTPUT_HANDLE

        # 获取当前控制台模式
        mode = wintypes.DWORD()
        if not kernel32.GetConsoleMode(handle, ctypes.byref(mode)):
            return False

        # 启用ANSI处理 (ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004)
        new_mode = mode.value | 0x0004
        if not kernel32.SetConsoleMode(handle, new_mode):
            return False

        return True
    except Exception:
        return False


def _detect_terminal_type() -> str:
    """检测终端类型"""
    # 检测PyCharm
    if 'PYCHARM_HOSTED' in os.environ or 'PYCHARM_MATPLOTLIB_BACKEND' in os.environ:
        return 'pycharm'

    # 检测VS Code
    if 'VSCODE_PID' in os.environ or 'TERM_PROGRAM' in os.environ and os.environ['TERM_PROGRAM'] == 'vscode':
        return 'vscode'

    # 检测其他IDE
    if any(ide in os.environ.get('PATH', '').lower() for ide in ['pycharm', 'vscode', 'code']):
        return 'ide'

    # Windows CMD
    if os.name == 'nt' and os.environ.get('TERM') != 'xterm':
        return 'cmd'

    # Unix终端
    return 'terminal'


# 颜色代码类
class Colors:
    RED = '\033[31m'
    YELLOW = '\033[33m'
    GREEN = '\033[32m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    RESET = '\033[0m'
    BRIGHT_RED = '\033[91m'

    # PyCharm专用颜色（更鲜艳但不刺眼）
    PYCHARM_YELLOW = '\033[93m'
    PYCHARM_RED = '\033[91m'
    PYCHARM_MAGENTA = '\033[95m'
    PYCHARM_BRIGHT_RED = '\033[1;31m'  # 粗体红色，不用背景色


# 检测终端类型和颜色支持
_TERMINAL_TYPE = _detect_terminal_type()
_COLOR_SUPPORT = _enable_windows_ansi_support() if _TERMINAL_TYPE == 'cmd' else True


# 根据终端类型选择颜色方案
def _get_level_colors():
    """根据终端类型获取级别颜色映射"""
    if _TERMINAL_TYPE == 'pycharm':
        return {
            WARNING: Colors.PYCHARM_YELLOW,
            ERROR: Colors.PYCHARM_RED,
            CRITICAL: Colors.PYCHARM_MAGENTA,
            EXCEPTION: Colors.PYCHARM_BRIGHT_RED,
        }
    else:
        return {
            WARNING: Colors.YELLOW,
            ERROR: Colors.RED,
            CRITICAL: Colors.MAGENTA,
            EXCEPTION: Colors.BRIGHT_RED,
        }


# 级别对应的颜色
LEVEL_COLORS = _get_level_colors()


class CustomLogger:
    """自定义日志器"""

    def __init__(self, name: str, console_level: Optional[int] = None, file_level: Optional[int] = None):
        self.name = name
        self._console_level = console_level
        self._file_level = file_level
        pass

    @property
    def console_level(self) -> int:
        """获取控制台日志级别"""
        if self._console_level is not None:
            return self._console_level

        level = get_console_level(self.name)
        return level

    @property
    def file_level(self) -> int:
        """获取文件日志级别"""
        if self._file_level is not None:
            return self._file_level

        level = get_file_level(self.name)
        return level

    def _should_log_console(self, level_value: int) -> bool:
        """判断是否应该输出到控制台"""
        result = level_value >= self.console_level
        return result

    def _should_log_file(self, level_value: int) -> bool:
        """判断是否应该输出到文件"""
        result = level_value >= self.file_level
        return result

    def _print_to_console(self, log_line: str, level_value: int) -> None:
        """输出到控制台"""
        try:
            # 选择输出流
            if level_value >= WARNING:
                output_stream = sys.stderr
            else:
                output_stream = sys.stdout

            # 添加颜色（如果支持）
            if _COLOR_SUPPORT and level_value in LEVEL_COLORS:
                colored_line = f"{LEVEL_COLORS[level_value]}{log_line}{Colors.RESET}"
            else:
                colored_line = log_line

            print(colored_line, file=output_stream, flush=True)

        except Exception as e:
            # 如果主要的print失败，尝试备用输出方式
            try:
                backup_message = f"控制台输出失败: {e}"
                print(backup_message, file=sys.stderr)
            except Exception:
                # 如果连备用输出都失败，则静默忽略
                pass

        return

    def _log(
            self,
            level_value: int,
            message: str,
            *args: Any,
            do_print: bool = True,
            **kwargs: Any
    ) -> None:
        """底层日志方法"""
        # 早期过滤：如果都不需要输出，直接返回
        should_console = do_print and self._should_log_console(level_value)
        should_file = self._should_log_file(level_value)

        if not should_console and not should_file:
            return

        try:
            level_name = get_level_name(level_value)
        except ValueError:
            level_name = f"LEVEL_{level_value}"

        # 创建日志行
        log_line = create_log_line(level_name, message, self.name, args, kwargs)

        # 获取异常信息（如果是exception级别）
        exception_info = None
        if level_value == EXCEPTION:
            exception_info = get_exception_info()

        # 控制台输出
        if should_console:
            self._print_to_console(log_line, level_value)
            if exception_info:
                try:
                    print(exception_info, file=sys.stderr)
                except Exception:
                    pass

        # 文件输出
        if should_file:
            write_log_async(log_line, level_value, exception_info)

        return

    # 标准级别方法
    def debug(self, message: str, *args: Any, **kwargs: Any) -> None:
        """调试级别日志"""
        self._log(DEBUG, message, *args, **kwargs)
        return

    def info(self, message: str, *args: Any, **kwargs: Any) -> None:
        """信息级别日志"""
        self._log(INFO, message, *args, **kwargs)
        return

    def warning(self, message: str, *args: Any, **kwargs: Any) -> None:
        """警告级别日志"""
        self._log(WARNING, message, *args, **kwargs)
        return

    def error(self, message: str, *args: Any, **kwargs: Any) -> None:
        """错误级别日志"""
        self._log(ERROR, message, *args, **kwargs)
        return

    def critical(self, message: str, *args: Any, **kwargs: Any) -> None:
        """严重错误级别日志"""
        self._log(CRITICAL, message, *args, **kwargs)
        return

    def exception(self, message: str, *args: Any, **kwargs: Any) -> None:
        """异常级别日志"""
        self._log(EXCEPTION, message, *args, **kwargs)
        return

    # 扩展级别方法
    def detail(self, message: str, *args: Any, **kwargs: Any) -> None:
        """详细调试级别日志"""
        self._log(DETAIL, message, *args, **kwargs)
        return

    def worker_summary(self, message: str, *args: Any, **kwargs: Any) -> None:
        """Worker摘要级别日志"""
        self._log(W_SUMMARY, message, *args, **kwargs)
        return

    def worker_detail(self, message: str, *args: Any, **kwargs: Any) -> None:
        """Worker详细级别日志"""
        self._log(W_DETAIL, message, *args, **kwargs)
        return

# ======= 源文件: src\custom_logger\manager.py =======
# src/custom_logger/manager.py
from __future__ import annotations
from datetime import datetime

start_time = datetime.now()

import atexit
from typing import Optional
from .config import init_config, get_config
from .writer import init_writer, shutdown_writer
from .logger import CustomLogger
from .types import parse_level_name

# 全局状态
_initialized = False


def init_custom_logger_system(config_path: Optional[str] = None) -> None:
    """初始化自定义日志系统（仅主程序调用）

    Args:
        config_path: 配置文件路径（可选），如果不提供则使用默认路径
    """
    global _initialized

    if _initialized:
        return

    try:
        # 初始化配置，传递配置路径
        init_config(config_path)

        # 初始化异步写入器
        init_writer()

        # 注册退出时清理
        atexit.register(tear_down_custom_logger_system)

        _initialized = True

    except Exception as e:
        # 避免在测试环境中输出到可能已关闭的stderr
        try:
            import sys
            print(f"日志系统初始化失败: {e}", file=sys.stderr)
        except (ValueError, AttributeError, ImportError):
            # 如果所有输出都失败，则静默处理
            pass
        raise

    return


def get_logger(
        name: str,
        console_level: Optional[str] = None,
        file_level: Optional[str] = None
) -> CustomLogger:
    """获取logger实例

    Args:
        name: logger名称
        console_level: 控制台日志级别（可选）
        file_level: 文件日志级别（可选）

    Returns:
        CustomLogger实例
    """
    # 检查系统是否已初始化
    if not _initialized:
        try:
            get_config()  # 尝试获取配置，如果失败则未初始化
        except RuntimeError:
            # 如果未初始化，自动初始化（兼容性处理）
            init_custom_logger_system()

    # 解析级别参数
    console_level_value = None
    file_level_value = None

    if console_level is not None:
        console_level_value = parse_level_name(console_level)

    if file_level is not None:
        file_level_value = parse_level_name(file_level)

    # 创建logger实例
    logger = CustomLogger(name, console_level_value, file_level_value)
    return logger


def tear_down_custom_logger_system() -> None:
    """清理自定义日志系统"""
    global _initialized

    try:
        # 关闭异步写入器
        shutdown_writer()
    except Exception as e:
        # 避免在测试环境中输出到可能已关闭的stderr
        try:
            import sys
            print(f"日志系统清理失败: {e}", file=sys.stderr)
        except (ValueError, AttributeError, ImportError):
            # 如果所有输出都失败，则静默处理
            pass
    finally:
        # 无论如何都要重置状态
        _initialized = False

    return


def is_initialized() -> bool:
    """检查日志系统是否已初始化"""
    return _initialized

# ======= 源文件: src\custom_logger\types.py =======
# src/custom_logger/types.py
from __future__ import annotations
from datetime import datetime

start_time = datetime.now()

from typing import Dict, Any

# 日志级别常量定义
DEBUG = 10
INFO = 20
WARNING = 30
ERROR = 40
CRITICAL = 50
EXCEPTION = 60

# 扩展级别常量
DETAIL = 8
W_SUMMARY = 5
W_DETAIL = 3

# 级别名称到数值的映射
LEVEL_NAME_TO_VALUE: Dict[str, int] = {
    "debug": DEBUG,
    "info": INFO,
    "warning": WARNING,
    "error": ERROR,
    "critical": CRITICAL,
    "exception": EXCEPTION,
    "detail": DETAIL,
    "w_summary": W_SUMMARY,
    "w_detail": W_DETAIL,
}

# 数值到级别名称的映射
VALUE_TO_LEVEL_NAME: Dict[int, str] = {v: k for k, v in LEVEL_NAME_TO_VALUE.items()}


def parse_level_name(level_name: str) -> int:
    """解析级别名称为数值"""
    if not isinstance(level_name, str):
        raise ValueError(f"级别名称必须是字符串，得到: {type(level_name)}")

    name = level_name.strip().lower()
    if name not in LEVEL_NAME_TO_VALUE:
        valid_levels = ", ".join(LEVEL_NAME_TO_VALUE.keys())
        raise ValueError(f"无效的日志级别: {level_name}，有效级别: {valid_levels}")

    result = LEVEL_NAME_TO_VALUE[name]
    return result


def get_level_name(level_value: int) -> str:
    """获取级别数值对应的名称"""
    if level_value not in VALUE_TO_LEVEL_NAME:
        raise ValueError(f"无效的日志级别数值: {level_value}")

    result = VALUE_TO_LEVEL_NAME[level_value]
    return result

# ======= 源文件: src\custom_logger\writer.py =======
# src/custom_logger/writer.py
from __future__ import annotations
from datetime import datetime

start_time = datetime.now()

import os
import sys
import threading
import queue
from typing import Optional, TextIO
from .config import get_config
from .types import ERROR

# 全局队列和线程
_log_queue: Optional[queue.Queue] = None
_writer_thread: Optional[threading.Thread] = None
_stop_event: Optional[threading.Event] = None

# 队列结束标记
QUEUE_SENTINEL = object()


class LogEntry:
    """日志条目"""

    def __init__(self, log_line: str, level_value: int, exception_info: Optional[str] = None):
        self.log_line = log_line
        self.level_value = level_value
        self.exception_info = exception_info
        pass


class FileWriter:
    """文件写入器"""

    def __init__(self, session_dir: str):
        self.session_dir = session_dir
        self.full_log_file: Optional[TextIO] = None
        self.error_log_file: Optional[TextIO] = None
        self._init_files()
        pass

    def _init_files(self) -> None:
        """初始化日志文件"""
        try:
            # 规范化路径，确保使用正确的分隔符
            normalized_session_dir = os.path.normpath(self.session_dir)
            os.makedirs(normalized_session_dir, exist_ok=True)

            full_log_path = os.path.join(normalized_session_dir, "full.log")
            error_log_path = os.path.join(normalized_session_dir, "error.log")

            self.full_log_file = open(full_log_path, 'a', encoding='utf-8', buffering=1)
            self.error_log_file = open(error_log_path, 'a', encoding='utf-8', buffering=1)

        except Exception as e:
            try:
                print(f"无法创建日志文件: {e}", file=sys.stderr)
            except (ValueError, AttributeError):
                pass

        return

    def write_log(self, entry: LogEntry) -> None:
        """写入日志条目"""
        try:
            # 写入完整日志
            if self.full_log_file:
                self.full_log_file.write(entry.log_line + '\n')
                if entry.exception_info:
                    self.full_log_file.write(entry.exception_info + '\n')
                self.full_log_file.flush()

            # 写入错误日志（ERROR及以上级别）
            if entry.level_value >= ERROR and self.error_log_file:
                self.error_log_file.write(entry.log_line + '\n')
                if entry.exception_info:
                    self.error_log_file.write(entry.exception_info + '\n')
                self.error_log_file.flush()

        except Exception as e:
            try:
                print(f"写入日志文件失败: {e}", file=sys.stderr)
            except (ValueError, AttributeError):
                pass

        return

    def close(self) -> None:
        """关闭文件"""
        try:
            if self.full_log_file:
                self.full_log_file.close()
                self.full_log_file = None

            if self.error_log_file:
                self.error_log_file.close()
                self.error_log_file = None

        except Exception as e:
            try:
                print(f"关闭日志文件失败: {e}", file=sys.stderr)
            except (ValueError, AttributeError):
                pass

        return


def _writer_thread_func() -> None:
    """写入线程主函数"""
    try:
        cfg = get_config()
        session_dir = getattr(cfg, 'current_session_dir', None)

        if session_dir is None:
            print("无法获取会话目录", file=sys.stderr)
            return

        writer = FileWriter(session_dir)
    except Exception as e:
        try:
            print(f"初始化文件写入器失败: {e}", file=sys.stderr)
        except (ValueError, AttributeError):
            pass
        return

    try:
        while True:
            try:
                # 从队列获取日志条目
                entry = _log_queue.get(timeout=1.0)

                # 检查结束标记
                if entry is QUEUE_SENTINEL:
                    break

                # 写入日志
                writer.write_log(entry)

            except queue.Empty:
                # 检查停止事件
                if _stop_event and _stop_event.is_set():
                    break
                continue
            except Exception as e:
                print(f"写入线程异常: {e}", file=sys.stderr)

    finally:
        writer.close()

    return


def init_writer() -> None:
    """初始化异步写入器"""
    global _log_queue, _writer_thread, _stop_event

    if _log_queue is not None:
        return  # 已经初始化

    try:
        _log_queue = queue.Queue(maxsize=1_000)
        _stop_event = threading.Event()
        _writer_thread = threading.Thread(target=_writer_thread_func, daemon=True)
        _writer_thread.start()

    except Exception as e:
        # 避免在测试环境中输出到可能已关闭的stderr
        try:
            print(f"初始化写入器失败: {e}", file=sys.stderr)
        except (ValueError, AttributeError):
            # 如果stderr不可用，静默处理
            pass

    return


def write_log_async(log_line: str, level_value: int, exception_info: Optional[str] = None) -> None:
    """异步写入日志"""
    if _log_queue is None:
        return

    try:
        entry = LogEntry(log_line, level_value, exception_info)
        _log_queue.put_nowait(entry)

    except queue.Full:
        try:
            print("日志队列已满，丢弃日志", file=sys.stderr)
        except (ValueError, AttributeError):
            pass
    except Exception as e:
        try:
            print(f"日志写入失败: {e}", file=sys.stderr)
        except (ValueError, AttributeError):
            pass

    return


def shutdown_writer() -> None:
    """关闭异步写入器"""
    global _log_queue, _writer_thread, _stop_event

    try:
        if _log_queue is not None:
            _log_queue.put(QUEUE_SENTINEL)

        if _stop_event is not None:
            _stop_event.set()

        if _writer_thread is not None and _writer_thread.is_alive():
            _writer_thread.join(timeout=5.0)

    except Exception as e:
        try:
            print(f"关闭写入器失败: {e}", file=sys.stderr)
        except (ValueError, AttributeError):
            pass
    finally:
        _log_queue = None
        _writer_thread = None
        _stop_event = None

    return

# ======= 源文件: src\demo\demo_custom_logger.py =======
# src/demo/demo_custom_logger.py
from __future__ import annotations
from datetime import datetime

start_time = datetime.now()

import time
import threading
import multiprocessing
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
from custom_logger import init_custom_logger_system, get_logger, tear_down_custom_logger_system


def demo_basic_usage():
    """演示基本用法"""
    print("\n=== 基本用法演示 ===")

    # 获取logger
    logger = get_logger("main")

    # 记录不同级别的日志
    logger.debug("这是调试信息")
    logger.detail("这是详细调试信息")
    logger.info("程序启动成功")
    logger.warning("这是一个警告")
    logger.error("这是一个错误")
    logger.critical("这是严重错误")

    # 带参数的日志
    user = "Alice"
    count = 42
    logger.info("用户 {} 有 {} 条消息", user, count)
    logger.info("用户 {user} 有 {count} 条消息", user=user, count=count)

    pass


def demo_worker_usage():
    """演示Worker用法"""
    print("\n=== Worker用法演示 ===")

    # Worker logger使用特殊级别
    worker_logger = get_logger("worker", console_level="w_summary")

    worker_logger.worker_summary("Worker开始处理任务")
    worker_logger.worker_detail("正在处理数据...")
    worker_logger.worker_detail("处理进度: 50%")
    worker_logger.worker_summary("Worker任务完成")

    pass


def demo_exception_handling():
    """演示异常处理"""
    print("\n=== 异常处理演示 ===")

    logger = get_logger("exception_demo")

    try:
        # 故意引发异常
        numbers = [1, 2, 3]
        result = numbers[10]  # 索引错误
    except IndexError:
        logger.exception("发生索引错误")

    try:
        # 另一种异常
        result = 10 / 0
    except ZeroDivisionError:
        logger.exception("发生除零错误")

    pass


def demo_different_levels():
    """演示不同级别设置"""
    print("\n=== 不同级别设置演示 ===")

    # 高级别logger（只显示重要信息）
    high_level_logger = get_logger("important", console_level="warning", file_level="error")

    # 低级别logger（显示所有信息）
    detailed_logger = get_logger("detailed", console_level="debug", file_level="debug")

    print("高级别logger输出：")
    high_level_logger.debug("这条不会显示")
    high_level_logger.info("这条也不会显示")
    high_level_logger.warning("这条会显示")
    high_level_logger.error("这条也会显示")

    print("\n详细logger输出：")
    detailed_logger.debug("调试信息会显示")
    detailed_logger.info("普通信息会显示")
    detailed_logger.warning("警告信息会显示")

    pass


def worker_thread_function(worker_id: int, task_count: int):
    """线程worker函数"""
    worker_logger = get_logger(f"thread_worker_{worker_id}", console_level="w_summary")

    worker_logger.worker_summary(f"线程Worker {worker_id} 启动，处理 {task_count} 个任务")

    for i in range(task_count):
        worker_logger.worker_detail(f"Thread-{worker_id} 处理任务 {i + 1}/{task_count}")
        time.sleep(0.1)  # 模拟工作

    worker_logger.worker_summary(f"线程Worker {worker_id} 完成所有任务")
    return f"Thread-{worker_id} completed {task_count} tasks"


def worker_process_function(worker_id: int, task_count: int):
    """进程worker函数"""
    # 进程中需要重新获取logger
    worker_logger = get_logger(f"process_worker_{worker_id}", console_level="w_summary")

    worker_logger.worker_summary(f"进程Worker {worker_id} 启动，处理 {task_count} 个任务")

    for i in range(task_count):
        worker_logger.worker_detail(f"Process-{worker_id} 处理任务 {i + 1}/{task_count}")
        time.sleep(0.05)  # 模拟工作

    worker_logger.worker_summary(f"进程Worker {worker_id} 完成所有任务")
    return f"Process-{worker_id} completed {task_count} tasks"


def demo_multithreading():
    """演示多线程场景"""
    print("\n=== 多线程演示 ===")

    main_logger = get_logger("main")
    main_logger.info("启动多线程任务")

    # 使用ThreadPoolExecutor
    with ThreadPoolExecutor(max_workers=3) as executor:
        futures = []
        for i in range(3):
            future = executor.submit(worker_thread_function, i, 3)
            futures.append(future)

        # 等待所有任务完成
        for future in futures:
            result = future.result()
            main_logger.info(f"线程任务完成: {result}")

    main_logger.info("所有线程任务完成")
    pass


def demo_multiprocessing():
    """演示多进程场景"""
    print("\n=== 多进程演示 ===")

    main_logger = get_logger("main")
    main_logger.info("启动多进程任务")

    # 使用ProcessPoolExecutor
    with ProcessPoolExecutor(max_workers=2) as executor:
        futures = []
        for i in range(2):
            future = executor.submit(worker_process_function, i, 2)
            futures.append(future)

        # 等待所有任务完成
        for future in futures:
            result = future.result()
            main_logger.info(f"进程任务完成: {result}")

    main_logger.info("所有进程任务完成")
    pass


def demo_format_examples():
    """演示格式化示例"""
    print("\n=== 格式化示例演示 ===")

    logger = get_logger("format_demo")

    # 各种格式化方式
    logger.info("简单消息")
    logger.info("位置参数: {}, {}, {}", "第一个", "第二个", "第三个")
    logger.info("关键字参数: {name} 年龄 {age}", name="张三", age=25)
    logger.info("混合参数: {} 在 {city} 工作", "李四", city="北京")

    # 数字格式化
    logger.info("处理了 {:,} 条记录", 1_234_567)
    logger.info("成功率: {:.2%}", 0.95)
    logger.info("文件大小: {:.2f} MB", 1024.5)

    # 格式化错误处理
    logger.info("参数不匹配: {} 和 {}", "只有一个参数")

    pass


def demo_performance_test():
    """演示性能测试"""
    print("\n=== 性能测试演示 ===")

    # 创建高级别logger，大部分日志会被过滤
    perf_logger = get_logger("performance", console_level="error", file_level="error")

    print("测试10,000条被过滤的日志性能...")
    start_time = time.time()

    for i in range(10_000):
        perf_logger.debug(f"性能测试消息 {i}")  # 这些会被过滤

    end_time = time.time()
    duration = end_time - start_time

    main_logger = get_logger("main")
    main_logger.info(f"10,000条被过滤日志耗时: {duration:.3f}秒")

    pass


def demo_color_levels():
    """演示颜色级别"""
    print("\n=== 颜色级别演示 ===")

    logger = get_logger("color_demo", console_level="debug")

    logger.debug("DEBUG级别 - 无颜色")
    logger.detail("DETAIL级别 - 无颜色")
    logger.info("INFO级别 - 无颜色")
    logger.warning("WARNING级别 - 黄色")
    logger.error("ERROR级别 - 红色")
    logger.critical("CRITICAL级别 - 洋红色")

    # 异常级别演示
    try:
        raise ValueError("演示异常")
    except ValueError:
        logger.exception("EXCEPTION级别 - 亮红色")

    pass


def main():
    """主函数"""
    print("自定义Logger完整演示程序")
    print("=" * 60)

    try:
        # 初始化日志系统（仅主程序需要）
        init_custom_logger_system()

        # 运行各种演示
        demo_basic_usage()
        demo_worker_usage()
        demo_exception_handling()
        demo_different_levels()
        demo_multithreading()
        demo_multiprocessing()
        demo_format_examples()
        demo_performance_test()
        demo_color_levels()

        print("\n=== 演示完成 ===")
        print("日志文件已保存到配置的目录中")
        print("请检查控制台颜色显示和文件输出")

    except Exception as e:
        print(f"演示过程中发生错误: {e}")
        import traceback
        traceback.print_exc()
    finally:
        # 清理日志系统
        tear_down_custom_logger_system()
        print("日志系统已清理")


if __name__ == "__main__":
    main()

# ======= 源文件: src\demo\config\config.yaml =======
__data__:
  base_dir: d:/logs
  experiment_name: default
  first_start_time: '2025-06-01T16:23:31.119377'
  logger:
    current_session_dir: d:/logs\my_project\default\logs\20250601\162331
    global_console_level: info
    global_file_level: debug
    module_levels: {}
  project_name: my_project
__type_hints__: {}


# ======= 源文件: src\demo\config\custom_logger.yaml =======
__data__:
  custom_logger:
    base_log_dir: d:/logs
    current_session_dir: d:/logs\my_project\default\logs\20250530\012036
    experiment_name: default
    first_start_time: '2025-05-30T01:20:36.210173'
    global_console_level: info
    global_file_level: debug
    module_levels: {}
    project_name: my_project
__type_hints__: {}


